# 函数的节流与防抖



```js
// 节流
function throttle(fn, time) {
    // 设置初始时间
    let pre = 0;
    // 返回一个新的函数
    return () => {
        // 记录当前时间
        let now = Date.now();
        // 通过时间差来进行节流
        if (now - pre > time) {
            // 执行fn函数
            fn.apply(this, arguments);
            // 更新pre的时间
            pre = now;
        }
    }
}

// 防抖
function debounce(fn, time, isNow) {
    // 设置定时器变量
    let timer;
    return () => {
        // 默认首次是立即触发的，不应该一上来就延迟执行fn
        if (isNow) {
            fn.apply(this, arguments);
            isNow = false;
            return;
        }
        // 如果上一个定时器还在执行，就直接返回    
        if (timer) return;
        // 设置定时器
        timer = setTimeout(() => {
            fn.apply(this, arguments);
            // 清除定时器
            clearTimeout(timer);
            timer = null;
        }, time);
    }
}

```







```js
/**
 * @param {Function} func
 * @param {number} wait
 * @param {boolean} immediate
 * @return {*}
 */
export function debounce(func, wait, immediate) {
    let timeout, args, context, timestamp, result;

    const later = function() {
        // 据上一次触发时间间隔
        const last = Number(new Date()) - timestamp;

        // 上次被包装函数被调用时间间隔 last 小于设定时间间隔 wait
        if (last < wait && last > 0) {
            timeout = setTimeout(later, wait - last);
        } else {
            timeout = null;
            // 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用
            if (!immediate) {
                result = func.apply(context, args);
                if (!timeout) {
                    context = args = null;
                }
            }
        }
    };

    return function(...args) {
        context = this;
        timestamp = Number(new Date());
        const callNow = immediate && !timeout;
        // 如果延时不存在，重新设定延时
        if (!timeout) {
            timeout = setTimeout(later, wait);
        }
        if (callNow) {
            result = func.apply(context, args);
            context = args = null;
        }

        return result;
    };
}
```





delay	为延迟执行的时间

duration	为时间间隔

```js
// 用于函数节流
fnThrottle(method, delay, duration) {
    var that = this;
    var timer = this.timer;
    var begin = new Date().getTime();
    return function() {
        var context = that;
        var args = arguments;
        var current = new Date().getTime();
        clearTimeout(timer);
        if (current - begin >= duration) {
            method.apply(context, args);
            begin = current;
        } else {
            that.timer = setTimeout(function() {
                method.apply(context, args);
            }, delay);
        }
    };
},
```

