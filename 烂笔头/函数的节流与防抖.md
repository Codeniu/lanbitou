# 函数的节流与防抖



```js
// 节流
function throttle(fn, time) {
    // 设置初始时间
    let pre = 0;
    // 返回一个新的函数
    return () => {
        // 记录当前时间
        let now = Date.now();
        // 通过时间差来进行节流
        if (now - pre > time) {
            // 执行fn函数
            fn.apply(this, arguments);
            // 更新pre的时间
            pre = now;
        }
    }
}

// 防抖
function debounce(fn, time, isNow) {
    // 设置定时器变量
    let timer;
    return () => {
        // 默认首次是立即触发的，不应该一上来就延迟执行fn
        if (isNow) {
            fn.apply(this, arguments);
            isNow = false;
            return;
        }
        // 如果上一个定时器还在执行，就直接返回    
        if (timer) return;
        // 设置定时器
        timer = setTimeout(() => {
            fn.apply(this, arguments);
            // 清除定时器
            clearTimeout(timer);
            timer = null;
        }, time);
    }
}

```

