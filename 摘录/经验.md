  /**

   \* 确定时返回组件调用处所需的数据

   \* 裁剪

   */

  cutimage() {

   *console*.log("执行裁剪操作");

   *var* point = [];

   this.customcxt.clearRect(0, 0, this.DivWidth, this.DivHeight);

   //根据绘制进行图片裁剪

   if (this.startX == 0) {

​    this.$message("请先选择要裁剪的区域！");

​    return;

   }

   //获取矩形框Left，Width'

   // let cLeft = 0; //

   // let cWidth = 0;

   // if (this.startX > this.endX) {

   // // 如果矩形是从右下角到左上角画

   //  cLeft = this.endX; //矩形左边框距离图片左边框的长度

   //  cWidth = this.startX - this.endX; //矩形框的宽

   // } else {

   //  //如果矩形是从左上角到右下角

   //  cLeft = this.startX; //矩形左边框距离图片左边框的长度

   //  cWidth = this.endX - this.startX; //矩形框的宽

   // }



   // //获取矩形框Top，Height

   // let cTop = 0;

   // let cHeight = 0;

   // if (this.startY > this.endY) {

   //  //如果矩形是从右下角到左上角画

   //  cTop = this.endY; //矩形上边框距离图片上边框的长度

   //  cHeight = this.startY - this.endY; //矩形框的高

   // } else {

   //  //如果矩形是从左上角到右下角

   //  cTop = this.startY; //矩形上边框距离图片上边框的长度

   //  cHeight = this.endY - this.startY; //矩形框的高

   // }



   // console.log(

   //  "确定后矩形" +

   //   "  endX " +

   //   this.endX +

   //   "  endY  " +

   //   this.endY +

   //   "  startX  " +

   //   this.startX +

   //   "  startY   " +

   //   this.startY

   // );



   // this.onSub();



   // this.$emit('custom',{'type':2,'data':oMark});

   //设置坐标数组

   point.push(this.startX);

   point.push(this.startY);

   point.push(this.endX);

   point.push(this.endY);

   *var* imgUrl = this.urls[this.img_index];

   this.imgForProcess =

​    "coral-base/api/coral/base/imageProcess/cutImg?fileName=" +

​    imgUrl.substring(imgUrl.lastIndexOf("/") + 1) +

​    "&fileType=DA&coordinate=" +

​    this.complieBaifenbi(point);

  },



  //计算百分比

  complieBaifenbi(*point*) {

   *let* imgWidth = document.getElementById("image_div1_img").width;

   *let* imgHeight = document.getElementById("image_div1_img").height;

   point[0] = ((point[0] * 100) / imgWidth).toFixed(2) - 0;

   point[1] = ((point[1] * 100) / imgHeight).toFixed(2) - 0;

   point[2] = ((point[2] * 100) / imgWidth).toFixed(2) - 0;

   point[3] = ((point[3] * 100) / imgHeight).toFixed(2) - 0;

   for (*let* i = 0; i < point.length; i++) {

​    if (point[i] > 100) {

​     point[i] = 100;

​    }

   }

   return point;

  },



  /**

   \* 去污

   */

  decontamination(*type*) {

   if (!this.checkPointXY(type)) {

​    this.$message("请先选择操作的区域！");

​    return;

   }

   *var* fileType = "DA";

   // var startX = 0;

   // var startY = 0;

   // var endX = 0;

   // var endY = 0;

   *var* point = [];

   *var* imgUrl = "";

   if (type != 1) {

​    fileType = "HDMI";

​    this.customcxt.clearRect(0, 0, this.DivWidthHdmi, this.DivHeightHdmi);

​    point.push(this.startXHdmi);

​    point.push(this.startYHdmi);

​    point.push(this.endXHdmi);

​    point.push(this.endYHdmi);

​    imgUrl = this.urlsHdmi[this.img_index];

​    if (imgUrl == null) {

​     imgUrl = this.urls[this.img_index];

​    }

   } else {

​    this.customcxt.clearRect(0, 0, this.DivWidth, this.DivHeight);

​    point.push(this.startX);

​    point.push(this.startY);

​    point.push(this.endX);

​    point.push(this.endY);

​    imgUrl = this.urls[this.img_index];

   }

   //根据绘制进行图片裁剪

   if (point[0] == 0) {

​    this.$message("请先选择要去污的区域！");

​    return;

   }

   *var* reqUrl =

​    "coral-base/api/coral/base/imageProcess/decontaminateImg?fileName=" +

​    imgUrl.substring(imgUrl.lastIndexOf("/") + 1) +

​    "&fileType=" +

​    fileType +

​    "&coordinate=" +

​    this.complieBaifenbi(point);

   if (type == 1) {

​    this.imgForProcess = reqUrl;

   } else {

​    this.imgForProcessHdmi = reqUrl;

   }

  },

  //校验坐标

  checkPointXY(*type*) {

   if (type == 1) {

​    if (

​     this.startX == 0 &&

​     this.startY == 0 &&

​     this.endX == 0 &&

​     this.endY == 0

​    ) {

​     return false;

​    }

   } else {

​    if (

​     this.startXHdmi == 0 &&

​     this.startYHdmi == 0 &&

​     this.endXHdmi == 0 &&

​     this.endYHdmi == 0

​    ) {

​     return false;

​    }

   }

   return true;

  },

  //清除坐标

  clearPointXY(*type*) {

   // console.log("%%%%%%%%%%%%%"+document.getElementById("image_div"+type+"_img").complete);

   // if (document.getElementById("image_div"+type+"_img").complete) {



   // } else {

   //  setTimeout(this.clearPointXY(type), 20);

   // }

   if (type == 1) {

​    this.startX = 0;

​    this.startY == 0;

​    this.endX == 0;

​    this.endY == 0;

   } else {

​    this.startXHdmi == 0;

​    this.startYHdmi == 0;

​    this.endXHdmi == 0;

​    this.endYHdmi == 0;

   }

  },

  /**

   \* 纠偏

   */

  rectifyDeviation() {

   *var* point = [];

   *var* imgUrl = "";

   //根据绘制进行图片裁剪

   if (this.startX == 0) {

​    this.$message("请先选择要纠偏的起始及结束点！");

​    return;

   }

   this.customcxt.clearRect(0, 0, this.DivWidth, this.DivHeight);

   point.push(this.startX);

   point.push(this.startY);

   point.push(this.endX);

   point.push(this.endY);

   imgUrl = this.urls[this.img_index];

   this.imgForProcess =

​    "coral-base/api/coral/base/imageProcess/rotateImg?fileName=" +

​    imgUrl.substring(imgUrl.lastIndexOf("/") + 1) +

​    "&fileType=DA&coordinate=" +

​    this.complieBaifenbi(point);

  },

  //旋转

  revolve() {

   *var* imgUrl = this.urls[this.img_index];

   this.imgForProcess =

​    "coral-base/api/coral/base/imageProcess/rotationImg?fileName=" +

​    imgUrl.substring(imgUrl.lastIndexOf("/") + 1) +

​    "&fileType=DA&direction=right&time=" +

​    new Date().getTime();

  },

  toHdmiImage() {

   *console*.log("转高清");

   *var* imgUrl = "";

   // this.customcxt.clearRect(0, 0, this.DivWidth, this.DivHeight);

   imgUrl = this.urls[this.img_index];

   this.imgForProcessHdmi =

​    "coral-base/api/coral/base/imageProcess/definitionImg?fileName=" +

​    imgUrl.substring(imgUrl.lastIndexOf("/") + 1) +

​    "&fileType=DA&time=" +

​    new Date().getTime();

  },