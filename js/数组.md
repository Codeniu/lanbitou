## 1比较两个数组是否相等

要转换为string进行比较

```
let arr1 = [1,2,3]
let arr2 = [3,2,1]

arr1.toString() === arr2.toString() // false
```

数组中的元素，与顺序均会改变



## 2 在forEach中使用push函数需要注意的地方

```js
let params = []    
let obj = {
    classifyId: this.currentClassifyRow.id,
    corpId: this.currentClassifyRow.corpId,
}
this.unselectedTable_selectedData.forEach(item => {
    obj['personId'] = item.id
    params.push(obj)
});
console.log("post's params", params);
```

想要的结果：

```js
0: {classifyId: 16, corpId: "2021", personId: 3773}
1: {classifyId: 16, corpId: "2021", personId: 6031}
2: {classifyId: 16, corpId: "2021", personId: 6034}
length: 3
__proto__: Array(0)
```

实际上：

```js
0: {classifyId: 16, corpId: "2021", personId: 6034}
1: {classifyId: 16, corpId: "2021", personId: 6034}
2: {classifyId: 16, corpId: "2021", personId: 6034}
length: 3
__proto__: Array(0)
```



解决：

```js
let params = []

for (let i = 0; i < this.unselectedTable_selectedData.length; i++) {
    const item = this.unselectedTable_selectedData[i];
    let obj = {
        classifyId: this.currentClassifyRow.id,
        corpId: this.currentClassifyRow.corpId,
        personId: item.id
    }
        params.push(obj)
}

console.log("post's params", params);
```

## 3.js数组合并concat()和Array.prototype.push.apply()的性能分析

js数组合并有两个常用方法，用法如下：

var a=[1,2,3],b=[4,5,6];

1.a.concat(b);//得到1,2,3,4,5,6；

1.1那个数组在前面合并后那个数组的元素就在前面

1.2 可以利用这个来复制一份数组，a.concat(a);

1.3 数组长度无限制，返回值是合并后的数组

1.4 千万级别的数组合并大约30毫秒



2.Array.prototype.push.apply(a,b)  or a.push.apply(a,b);

2.1.Array.prototype.push.apply(a,b) ;//a,b两个数组都变成合并后的数组

2.2 数组长度有限制，不同浏览器不同，一般不能超过十万

2.3返回值是合并后数组的长度

2.4 在一万数据左右性能和concat差不多，大约2毫秒



总结：测试结果可知，还是用concat会划算一点，看返回值也可以知道，apply方法改变两个数组，性能自然会慢，而且有局限性，在这里再扯多一句,很多人不知道什么时候用

json什么时候用数组，如果频繁添加删除的尽量用json，因为这是数组的短处，如果频繁取数据的用数组。时间有限，下次会专门来扯一扯这个话题。

共享一下测试concat()和Array.prototype.push.apply(a,b) 的代码，有需要的拿走玩玩

```js
function testClass(){
    var testArray1=[];
    var testArray2=[];
    this.resetArray=function(){
        for(var i=0; i<10000000;i++){
            testArray1.push(i);
            testArray2.push(i+10000000);
        }
    }
    this.applyTest=function(){
        var startTime=0,
            endTime=0;
        console.log('开始合并的时间是：'+ (startTime=new Date().getTime()));
        var aa=Array.prototype.push.apply(testArray1,testArray2);
        console.log(aa);
        console.log('合并完成的时间是：'+ (endTime=new Date().getTime()));
        console.log('合并数组所用的时间是：'+(endTime-startTime));
    }
    this.concatTest=function(){
         var startTime=0,
            endTime=0;
        console.log('开始合并的时间是：'+ (startTime=new Date().getTime()));
        var aa= testArray1.concat(testArray2);
        console.log(aa.length);
        console.log('合并完成的时间是：'+ (endTime=new Date().getTime()));
        console.log('合并数组所用的时间是：'+(endTime-startTime));
    }
}


var apply=new testClass();
apply.resetArray();
apply.applyTest();

var concat=new testClass();
concat.resetArray();
concat.concatTest();
```





## 4.JavaScript unshift() 方法

### 定义和用法

unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。

### 语法

```
arrayObject.unshift(newelement1,newelement2,....,newelementX)
```

| 参数        | 描述                           |
| :---------- | :----------------------------- |
| newelement1 | 必需。向数组添加的第一个元素。 |
| newelement2 | 可选。向数组添加的第二个元素。 |
| newelementX | 可选。可添加若干个元素。       |

### 返回值

arrayObject 的新长度。

### 说明

unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。

请注意，unshift() 方法不创建新的创建，而是直接修改原有的数组。

### 实例

在本例中，我们将创建一个数组，并把一个元素添加到数组的开头，并返回数组的新长度：

```
<script type="text/javascript">

var arr = new Array()
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"

document.write(arr + "<br />")
document.write(arr.unshift("William") + "<br />")
document.write(arr)

</script>
```

输出：

```js
George,John,Thomas4William,George,John,Thomas
```

```html
<html>
<body>

<script type="text/javascript">

var arr1 = ['a', 'b', 'c']; 
var arr2 = ['1', '2', '3']; 
// 把arr2 变成一个适合splice的数组（包含splice前2个参数的数组）
arr2.unshift(2, 0); 

document.write(arr2 + "<br />")

Array.prototype.splice.apply(arr1, arr2); 
console.log(arr1); 
//["a", "b", "1", "2", "3", "c"]

document.write(arr1 + "<br />")


</script>

</body>
</html>
```





# 5.Array.prototype.splice.apply(arr1, arr2);

**问题：**

arr1 = ['a', 'b', 'c'] 
arr2 = ['1', '2', '3'] 
把数组arr2插入数组arr1的第二个元素b后面；


**思路：** 
插入特定的位置，我们首先会想到splice，

***\*splice\****用法如下。index是索引，howmany是删除多少个元素，后面的item是插入的元素

```html
arrayObject.splice(index,howmany,item1,.....,itemX)
```

直接splice(2, 0, arr2)，但是结果：['a', 'b', ['1', '2', '3'], 'c']； 

我们可以用Fuction原型链上的方法用函数***\*apply\****（可以改变this的指向） 

![img](https://img-blog.csdnimg.cn/20181226182333242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdXl1bGl1,size_16,color_FFFFFF,t_70)
 **实现：**只需要两步：
**1.**我们要把arr2 变成一个适合splice的数组（包含splice前2个参数的数组） ：在arr2前面插入2个元素：splice前2个参数（开始位置，删除几个元素） **2.**把新得到的arr2整个数组做为参数传给arr1。

```javascript
var arr1 = ['a', 'b', 'c']; var arr2 = ['1', '2', '3']; // 把arr2 变成一个适合splice的数组（包含splice前2个参数的数组）arr2.unshift(2, 0); Array.prototype.splice.apply(arr1, arr2); console.log(arr1); //["a", "b", "1", "2", "3", "c"]
```

上面的代码相当于

```javascript
var arr1 = ['a', 'b', 'c']; var arr2 = ['1', '2', '3']; arr1.splice(2,0,'1','2','3')console.log(arr1)//["a", "b", "1", "2", "3", "c"]
```

