### 参考：

1.[身份证号码的正则表达式及验证详解(JavaScript，Regex) (juejin.cn)](https://juejin.cn/post/6844903575877861390#heading-22)

2.[身份证校验正则_齐枫的博客-CSDN博客](https://blog.csdn.net/qiphon3650/article/details/95495629)



### 身份证号的结构：

![](https://gitee.com/youngniu/pic-bed/raw/master/img/20201125104532.png)

1.号码的结构

公民身份号码是特征组合码，由十七位数字本体码和一位校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。

2.地址码
表示编码对象常住户口所在县（县级市、旗、区）的行政区划代码，按GB/T2260的规定执行。

3．出生日期码
表示编码对象出生的年、月、日，按GB/T7408的规定执行，年、月、日代码之间不用分隔符。

4．顺序码
表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。

5．校验码
根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。



### 计算方法

1、将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。
2、将这17位数字和系数相乘的结果相加。
3、用加出来和除以11，看余数是多少？
4、余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X －9－8－7－6－5－4－3－2。(即余数0对应1，余数1对应0，余数2对应X…)
5、通过上面得知如果余数是3，就会在身份证的第18位数字上出现的是9。如果对应的数字是2，身份证的最后一位号码就是罗马数字X。
例如：某男性的身份证号码为【53010219200508011X】， 我们看看这个身份证是不是合法的身份证。
首先我们得出前17位的乘积和【(5*7)+(3*9)+(0*10)+(1*5)+(0*8)+(2*4)+(1*2)+(9*1)+(2*6)+(0*3)+(0*7)+(5*9)+(0*10)+(8*5)+(0*8)+(1*4)+(1*2)】是189，然后用189除以11得出的结果是189/11=17----2，也就是说其余数是2。最后通过对应规则就可以知道余数2对应的检验码是X。所以，可以判定这是一个正确的身份证号码。



### 简单版正则

1.1 分部规则
我们首先提出方案1，并分步做如下规则定义：

1.1.1 地址码规则：
地址码长6位
以数字1-9开头
后5位为0-9的数字
根据以上规则，写出地址码的正则表达式： /[1](https://blog.csdn.net/qiphon3650/article/details/95495629#fn1)\d{5}/

1.1.2 年份码规则：
年份码长4位
以数字18，19或20,30开头
剩余两位为0-9的数字
根据以上规则，写出年份码的正则表达式： /(18|19|20|(3\d))\d{2}/。如果想扩展可以自己添加

1.1.3 月份码规则：
月份码长2位
第一位数字为0，第二位数字为1-9
或者第一位数字为1，第二位数字为0-2
根据以上规则，写出月份码的正则表达式： /((0[1-9])|(1[0-2]))/。

1.1.4 日期码规则：
日期码长2位
第一位数字为0-2，第二位数字为1-9
或者是10，20，30，31
根据以上规则，写出日期码的正则表达式 ：/(([0-2][1-9])|10|20|30|31)/。

1.1.5 顺序码规则：
顺序码长3位
顺序码是数字
根据以上规则，写出顺序码的正则表达式 ：/\d{3}/。

1.1.6 校验码规则：
校验码长1位
可以是数字，字母x或字母X
根据以上规则，写出校验码的正则表达式 ：/[0-9Xx]/。

```js
// 18
let reg18 = /^[1-9]\d{5}(18|19|20|(3\d))\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
/// 15 位
let reg15 = /^[1-9]\d{5}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}$/;
```



### 严格校验

```js
var Wi = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2, 1 ];    // 加权因子   
	var ValideCode = [ 1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2 ];            // 身份证验证位值.10代表X   
	function IdCardValidate(idCard) { 
	    idCard = trim(idCard.replace(/ /g, ""));               //去掉字符串头尾空格                     
	    if (idCard.length == 15) {   
	        return isValidityBrithBy15IdCard(idCard);       //进行15位身份证的验证    
	    } else if (idCard.length == 18) {   
	        var a_idCard = idCard.split("");                // 得到身份证数组   
	        if(isValidityBrithBy18IdCard(idCard)&&isTrueValidateCodeBy18IdCard(a_idCard)){   //进行18位身份证的基本验证和第18位的验证
	            return true;   
	        }else {   
	            return false;   
	        }   
	    } else {   
	        return false;   
	    }   
	}   
	/**  
	 * 判断身份证号码为18位时最后的验证位是否正确  
	 * @param a_idCard 身份证号码数组  
	 * @return  
	 */  
	function isTrueValidateCodeBy18IdCard(a_idCard) {   
	    var sum = 0;                             // 声明加权求和变量   
	    if (a_idCard[17].toLowerCase() == 'x') {   
	        a_idCard[17] = 10;                    // 将最后位为x的验证码替换为10方便后续操作   
	    }   
	    for ( var i = 0; i < 17; i++) {   
	        sum += Wi[i] * a_idCard[i];            // 加权求和   
	    }   
	    valCodePosition = sum % 11;                // 得到验证码所位置   
	    if (a_idCard[17] == ValideCode[valCodePosition]) {   
	        return true;   
	    } else {   
	        return false;   
	    }   
	}   
	/**  
	  * 验证18位数身份证号码中的生日是否是有效生日  
	  * @param idCard 18位书身份证字符串  
	  * @return  
	  */  
	function isValidityBrithBy18IdCard(idCard18){   
	    var year =  idCard18.substring(6,10);   
	    var month = idCard18.substring(10,12);   
	    var day = idCard18.substring(12,14);   
	    var temp_date = new Date(year,parseFloat(month)-1,parseFloat(day));   
	    // 这里用getFullYear()获取年份，避免千年虫问题   
	    if(temp_date.getFullYear()!=parseFloat(year)   
	          ||temp_date.getMonth()!=parseFloat(month)-1   
	          ||temp_date.getDate()!=parseFloat(day)){   
	            return false;   
	    }else{   
	        return true;   
	    }   
	}   
	  /**  
	   * 验证15位数身份证号码中的生日是否是有效生日  
	   * @param idCard15 15位书身份证字符串  
	   * @return  
	   */  
	  function isValidityBrithBy15IdCard(idCard15){   
	      var year =  idCard15.substring(6,8);   
	      var month = idCard15.substring(8,10);   
	      var day = idCard15.substring(10,12);   
	      var temp_date = new Date(year,parseFloat(month)-1,parseFloat(day));   
	      // 对于老身份证中的你年龄则不需考虑千年虫问题而使用getYear()方法   
	      if(temp_date.getYear()!=parseFloat(year)   
	              ||temp_date.getMonth()!=parseFloat(month)-1   
	              ||temp_date.getDate()!=parseFloat(day)){   
	                return false;   
	        }else{   
	            return true;   
	        }   
	  }   
	//去掉字符串头尾空格   
	function trim(str) {   
	    return str.replace(/(^\s*)|(\s*$)/g, "");   
	}  


IdCardValidate('41282519950903823X') // true
IdCardValidate('41282519950921823X') // false
130603196811190919 // true
411381198112253933 // true
```







### el-form的rules配置

```js
import { validateIdCardNumber } from '@/utils/formValidation';

rules:[
    idcardNum: [
        {
            required: true,
            message: '请输入身份证号',
            trigger: 'blur',
        },
        { validator: validateIdCardNumber, trigger: 'blur' },
    ],
]
```

